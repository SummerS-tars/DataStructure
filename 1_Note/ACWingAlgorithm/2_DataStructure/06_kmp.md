# KMP 算法

KMP算法属于一种双指针算法  

用途：  
KMP算法用于字符串匹配，在字符串中查找子串  

## 1. 理解

我们遵从先构思暴力做法，然后试图优化的流程

暴力做法的话  
我们考虑双重循环  
外层循环母串，作为子串匹配开头  
然后通过内层循环试图匹配子串  

这里暴力做法，我们如果匹配成功了某一段  
失败了，会直接将外层循环下移一次  
这里浪费了部分信息（来源于匹配成功的段）  

如何考虑使用这些信息呢？  
我们考虑子串已经匹配的部分，如果其开头某一部分和结尾某一部分相同  
那么我们可以直接将匹配头移到结尾的这一部分开头  
并直接从下一个开始匹配  

我们可以通过预处理子串  
生成一个next数组，用于记录子串中各个长度的段中，相同前后缀的最大长度  

### 1.1. 如何理解next数组的生成及其作用

next的生成：  

```cpp
for(int i = 1, j = 0; i < n; i ++){
    while(j && sub[i] != sub[j]) j = ne[j - 1];
    if(sub[i] == sub[j]) j ++;
    ne[i] = j;
}
```

非常巧妙的算法  

如何直观理解：  
i, j两个指针指向两个字符串  
i指向母串  
j指向用于匹配的模式串  
next生成过程中，表现为均指向子串  

i负责遍历用于匹配的串  
j负责指示已经匹配的公共串的末尾，用于与i所指字符进行比较  

如果成功  
i, j均向后移  

如果失败  
j开始回滚（j = ne\[j - 1]）  
并试图重新与i所指字符进行比较  
直到匹配成功或j回滚到0  

模拟时，可以将i所指的字符串看作不动  
j与i对其，模式串通过j进行定位在母串上移动  
j左侧的段为已经匹配成功的部分  
当j移动到模式串末尾时，说明匹配成功  

next数组的生成  
以及从母串中匹配模式串都可以如此理解  
next数组就是通过迭代提供用于优化匹配的回滚参考信息（next）  

具体来说  
next\[j]就表示如果模式串中0~j中最长的相同前后缀的长度  
由于字符串下标从0开始，因此其又表现为该前缀的下一个字符的下标  
如果第j+1个字符与母串中的字符i匹配失败，将j回滚到next\[j-1]  
并试图重新与i所指字符进行比较  
重复此过程  
直到匹配成功或者j回滚到0  
