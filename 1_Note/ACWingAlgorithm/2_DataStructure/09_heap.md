# 堆

堆（heap）是一种完全二叉树  

小根堆，每个节点小于等于它的子节点  

## 1. 小根堆

数组实现中  
子节点与父节点关系：  
下标为i的节点  
父节点：i / 2  
左子节点：i \* 2  
右子节点：i \* 2 + 1  
*下标应该从1开始*  

基础操作：  

1. down(x)  
2. up(x)  
    与父节点比较，如果小于就交换  
    直到满足小于父节点或者到达根节点  

*x指代下标*  

操作：  

1. 插入一个数  
    直接插入到数组末尾，然后up(x)  

    ```cpp
    heap[++ size] = x;
    up(size);
    ```

2. 求集合当中的最小值  
    直接返回数组第一个元素  

    ```cpp
    heap[1];
    ```

3. 删除最小值  
    将数组末尾元素赋值给数组第一个元素，然后down  

    ```cpp
    heap[1] = heap[size];
    size --;
    down(1);
    ```

4. 删除任意一个元素  
    将数组末尾元素赋值给该元素，然后down  

    ```cpp
    heap[k] = heap[size];
    size --;
    down(k);
    up(k);
    ```

    ? 这里是不是没有必要up  

5. 修改任意一个元素  
    将该元素赋值为新值，然后down或up  

    ```cpp
    heap[k] = x;
    down(k);
    up(k);
    ```

*后两者在cpp stl中无法直接实现*  

### 1.1. 对任意一个元素操作的实现

我们通过被插入数的顺序进行确定要操作的数  
*例如第k个插入的数*  

一般实际上用不到任意一个元素的操作  
但某些算法可能用到  

为了实现这样一个操作  
我们需要引入两个额外的数组  
用于记录并维护插入的顺序与节点在堆中的位置的一一映射关系  

1. 插入顺序到下标映射  
2. 下标到插入顺序映射  

```cpp
int ph[N]; // * 插入顺序到下标映射
int hp[N]; // * 下标到插入顺序映射
// p 表示 插入的序号，h 表示 堆的下标
```

然后为此堆实现一个专门的swap函数  

```cpp
void heap_swap(int a, int b){
    swap(ph[hp[a]], ph[hp[b]]); // * 交换插入顺序到下标映射
    swap(hp[a], hp[b]); // * 交换下标到插入顺序映射
    swap(heap[a], heap[b]); // * 交换节点
}
// ! 注意此处，a和b是节点在堆下标，而不是插入顺序
```
