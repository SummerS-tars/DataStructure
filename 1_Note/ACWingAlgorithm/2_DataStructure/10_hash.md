# 哈希表

两大部份内容  

1. 哈希表的存储结构
    1. 开放寻址法
    2. 拉链法
2. 常用的字符串哈希方式

## 哈希表的作用

将比较庞大的一个值域映射到一个较小的范围中  

常用情景：  
将一些从 $0$ 到 $10^9$ 的整数映射到 $0$ 到 $10^5$ 的整数中  

## 哈希表的存储结构

简单描述：  
通过一个函数（一般称为哈希函数）将一个值域映射到一个范围中，这个范围通常比值域小得多  
*之前所讲的离散化是一种特殊的哈希方式*  

相应的问题：  

1. 如何映射？  
    一般取模  
    且取模的数一般为质数  
    这样可以尽量减少冲突  
2. 如何解决可能的冲突？  
    看下面的方法  

### 拉链法

使用一个一维数组来储存所有的哈希值  
大小为元素的数量  

如何处理冲突？  
我们将该一维数组的每个位置视为一个槽  
每个槽可以拉一条链子  
每次我们讲某个数进行映射到某个槽时，就在对应槽的链子上加一个元素  
链的实现一般就是单链表  

我们对哈希表的实现一般只有插入和查找  
不包括删除操作  

### 开放寻址法

先通过哈希函数得到映射后的位置  
如果该位置已经有元素占据  
则直接向后寻找  
知道找到空的位置  

删除的实现一般通过添加标记来表示已删除  
可以看成查找的一种  

## 字符串前缀哈希法

流程：  
预处理出字符串所有前缀的哈希  

例子：  

```cpp
char str[] = "ABCDEFG";
h[0] = 0;
h[1] = h[0] * P + str[0];
//...
```

假设该字符串全都由大写字母构成  
考虑将字符串看作一个P进制的数  
我们考虑自然的左侧高位到右侧低位的表示顺序  

然后对转换之后的10进制数取模（模Q）  
然后就和普通哈希类似了  

注意不可以将数字映射成0  
一般映射为从1开始  
此外注意此处字符串哈希是不可以容忍冲突的  
*不可以容忍指这个错误没办法解决，只能尽量减少*  

常用取法：  
P = 131 or 13331  
Q = 2^64  

好处：  
是可以使用前缀哈希来求出任意子串的哈希值  
然后这个哈希值可以用来快速判断两个子串是否相同  

### 实现  

```cpp
// L ~ R 的子串的哈希值
sub_hash = h[R] - h[L - 1] * p[R - L + 1]
```

理解方式：  
从右边开始对其  
将字符串作为P进制数进行考虑  

