# Lab 6

23307110192  
朱文凯  

## Practice 01

采用BFS算法实现对Nested List的加权求和  

首先遍历得到最大深度，获取用于得到权重的信息  
然后再通过BFS进行加权求和  

具体来说为通过使用一个存储Nested Integer的指针以及其对应深度的pair的queue  
根据深度进行遍历  
具体来说为先将所有深度为1的Nested Integer的指针入队  
然后对每一个元素进行判断  
如果已经是当前最深的整数个体，则加权计入结果  
如果为Nested List，则将其内部所有的Nested Integer的指针以及对应深度入队  
重复上述过程直到队列为空  
结束即完成了对于所有数的加权求和  

## Practice 02

同样采用BFS算法实现八数码问题的求解  

首先将string的状态进行转换  
通过公式转换string中的线性位置与二维位置  

然后定义四个方向的移动  
先将初始状态入队  
然后使用BFS进行搜索求解  

具体讲解：  
对于对列中的每一个状态，找到空格的位置  
将其从对列中弹出  
然后尝试四个方向的移动  
如果移动合法则进行交换得到新的状态  
如果该状态没有被访问过则将其入队并标记为已访问  
将string每一步之后的状态以及其对应的步数组成pair存入一个unordered_map中  
如果匹配到目标状态则返回步数  
否则将改变后的状态push进入对列  
然后继续进行搜索  
如果对列为空则表示无法到达目标状态，返回-1  
