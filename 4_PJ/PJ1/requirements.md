# Project 1: 迷宫路径解析系统 - 设计与实现方案

本文档基于 `Project 1.md` 的要求，提供一个全面的系统设计方案和实施计划。

## 1. 项目概述

本项目旨在开发一个“迷宫路径解析系统”。该系统能够加载预设的迷宫地图，接收用户输入的字符指令（如 W, A, S, D）来控制角色在迷宫中移动，并支持路径记录、指令撤销、状态存读等一系列交互功能。

## 2. 核心数据结构设计

为了高效地实现项目要求，我们计划采用以下核心数据结构：

| 功能模块 | 选用数据结构 | 设计原因 |
| :--- | :--- | :--- |
| **地图表示** | `std::vector<std::string>` | 用于存储从文本文件加载的 N×M 迷宫。`vector<string>` 提供了二维数组的直观访问方式（`map[y][x]`），同时易于动态加载和管理。 |
| **玩家状态** | `struct Player` | 封装玩家的核心数据，如当前坐标 `(x, y)`。在多玩家模式下，可以轻松创建多个玩家实例 `std::vector<Player>`。 |
| **历史路径记录** | `std::stack<std::pair<int, int>>` | `std::stack` (栈) 的后进先出（LIFO）特性完美契合“撤销”功能。每次移动，将新坐标压入栈中；执行撤销（Undo）时，只需弹出栈顶元素即可回到上一个位置。 |
| **完整指令序列** | `std::vector<char>` | 用于记录用户输入的所有有效移动指令（W, A, S, D）。`std::vector` 是一个动态数组，可以方便地追加新指令，并支持从头到尾遍历，是实现“路径回放”功能的基础。 |
| **状态保存** | `struct GameState` | 封装需要保存的游戏状态，包括玩家位置、移动历史栈和指令序列。通过将此结构体序列化到文件，可以实现完整的状态保存与恢复。 |

---

## 3. 模块设计与功能实现

### 3.1. 基本功能

1. **地图加载与表示 (`Maze` 类)**
   * **实现**：创建一个 `Maze` 类，负责从 `.txt` 文件读取地图数据。提供一个 `load(const std::string& filename)` 方法。内部使用 `std::vector<std::string> map_data;` 存储地图。
   * **接口**：
     * `is_wall(int x, int y)`: 判断指定坐标是否为墙壁或越界。
     * `get_start_pos()`: 返回起点 'S' 的坐标。
     * `display()`: 在控制台打印当前地图和玩家位置。

2. **命令解析与执行 (`Game` 类)**
   * **实现**：`Game` 类作为游戏主逻辑控制器。它包含一个 `Player` 对象和一个 `Maze` 对象。主循环接收用户输入，并解析单个字符指令。
   * **逻辑**：对于移动指令 (W/A/S/D)，首先调用 `maze.is_wall()` 检查目标位置。如果可通行，则更新玩家坐标，并将新坐标压入历史路径栈；如果不可通行，则输出提示信息。

3. **路径记录与展示**
   * **实现**：当用户输入 'P' 时，需要按从起点到终点的顺序打印路径。由于栈是反序的，我们会临时将历史路径栈 `std::stack` 的内容复制到一个 `std::vector` 中，然后颠倒 `vector` 并遍历输出坐标。

4. **撤销功能 (Undo)**
   * **实现**：当用户输入 'U' 时，检查历史路径栈是否有多于一个元素（即不在起点）。如果有，弹出栈顶元素，并将玩家的位置更新为新的栈顶坐标。同时，从完整指令序列 `std::vector<char>` 中移除最后一个指令。

5. **到达检测**
   * **实现**：每次移动后，检查玩家当前坐标是否与终点 'E' 的坐标重合。如果重合，则触发成功逻辑：打印祝贺信息、总步数（即历史路径栈的大小减一）和完整路径。

### 3.2. 扩展功能

1. **路径回放 (Replay)**
   * **实现**：当用户输入 'R' 时，系统将重置玩家位置到起点，然后遍历存储在 `std::vector<char>` 中的完整指令序列，并依次执行每个移动指令，在每次移动后短暂延迟并刷新屏幕，以实现动画效果。

2. **状态保存与恢复 (Save/Load)**
   * **实现**：
     * **SAVE**: 创建一个 `GameState` 实例，将当前的玩家位置、历史路径栈和指令序列 `vector` 存入其中。然后将该结构体的内容写入二进制文件（例如 `game.save`）。
     * **LOAD**: 从文件中读取 `GameState` 数据，并用其内容覆盖当前游戏的状态。

3. **迷宫生成器**
   * **实现**：采用 **随机深度优先搜索 (Randomized DFS)** 算法。
     1. 创建一个 N×M 的网格，所有单元格初始时都是墙。
     2. 选择一个起始单元格，将其标记为通路，并将其压入一个栈。
     3. 当栈不为空时，查看栈顶单元格的未访问邻居。
     4. 如果存在未访问的邻居，随机选择一个，打通两个单元格之间的墙，将该邻居标记为已访问，并压入栈。
     5. 如果没有未访问的邻居，从栈中弹出一个单元格（回溯）。
     6. 重复此过程，直到所有可达单元格都被访问。最后随机设置起点 'S' 和终点 'E'。

4. **多角色竞争模式**
   * **实现**：
     * 将 `Player` 对象扩展为一个 `std::vector<Player>`。
     * 游戏主循环将变为回合制，轮流接收每个玩家的输入。例如，提示 "Player 1's turn:"，然后是 "Player 2's turn:"。
     * 每个玩家拥有独立的历史路径栈和指令序列。
     * 当任意一个玩家到达终点 'E' 时，宣布该玩家获胜，并结束游戏。

---

## 4. 用户交互界面设计

### 4.1. 游戏启动流程

当用户启动程序后，系统应提供清晰的交互界面，引导玩家完成游戏配置和开始游戏。

#### 4.1.1. 主菜单界面

程序启动后首先显示主菜单，提供以下选项：

```text
===================================
    迷宫路径解析系统 v1.0
===================================
1. 开始新游戏
2. 加载存档
3. 迷宫生成器（可选扩展功能）
4. 查看帮助
5. 退出程序
===================================
请选择功能 (1-5): _
```

**实现建议**：  

* 使用循环读取用户输入，直到输入有效选项
* 对无效输入进行友好的错误提示
* 可以使用 `std::cin` 读取用户选择

#### 4.1.2. 地图选择界面

当用户选择"开始新游戏"后，进入地图选择界面：

```text
===================================
        选择迷宫地图
===================================
可用地图列表：
1. Maze1.txt  (15x15 - 初级难度)
2. Maze2.txt  (21x21 - 中级难度)
3. 自定义地图（输入文件名）
===================================
请选择地图 (1-3): _
```

**实现建议**：  

* 自动扫描 `data/` 目录下的 `.txt` 文件并列出
* 允许用户输入自定义地图文件路径
* 加载地图前验证文件是否存在及格式是否正确
* 如果加载失败，返回地图选择界面

#### 4.1.3. 游戏模式选择

选择地图后，提示用户选择游戏模式：

```text
===================================
        选择游戏模式
===================================
1. 单人模式
2. 双人竞速模式（可选扩展功能）
===================================
请选择模式 (1-2): _
```

**实现建议**：  

* 对于单人模式，创建一个 `Player` 对象
* 对于双人模式，创建两个 `Player` 对象，并设置回合制逻辑
* 如果未实现多人模式，只显示单人模式选项

### 4.2. 游戏进行中的界面

#### 4.2.1. 游戏主界面

进入游戏后，应持续显示当前游戏状态：

```text
===================================
当前地图: Maze1.txt  |  模式: 单人
当前位置: (1, 1)     |  步数: 15
===================================
[迷宫地图显示区域]
###############
#@····#·······#
#·#·#·#·#####·#
#·#·#·#·····#·#
...
===================================
可用指令:
  W/A/S/D - 移动 (上/左/下/右)
  P - 打印完整路径
  U - 撤销上一步
  R - 路径回放
  SAVE - 保存游戏
  LOAD - 加载游戏
  HELP - 查看帮助
  QUIT - 退出游戏
===================================
请输入指令: _
```

**显示要素**：  

* 当前地图文件名和游戏模式
* 玩家当前位置坐标
* 已走步数
* 迷宫地图（用特殊字符标记玩家位置，如 `@` 或彩色高亮）
* 可用指令列表
* 输入提示符

**实现建议**：  

* 每次执行指令后刷新屏幕（使用清屏函数）
* 使用不同符号区分玩家、墙壁、通路、起点、终点
* 在多人模式下，使用不同符号表示不同玩家（如 `@` 和 `#`）

#### 4.2.2. 双人竞速模式界面（扩展功能）

在双人模式下，界面应显示两个玩家的状态：

```text
===================================
双人竞速模式 - Player 1 的回合
===================================
Player 1 位置: (3, 5)  |  步数: 12
Player 2 位置: (2, 8)  |  步数: 15
===================================
[迷宫地图 - 显示两个玩家位置]
###############
#·····#···@···#    @ = Player 1
#·#·#·#·#####·#    # = Player 2
#·#·#·#··#··#·#
...
===================================
Player 1 请输入指令 (W/A/S/D/P/U): _
```

### 4.3. 特殊提示信息

在游戏过程中，系统应及时反馈操作结果：

#### 4.3.1. 移动反馈

* **成功移动**：刷新地图，显示新位置
* **碰壁**：`"前方是墙壁，无法通行！"`
* **越界**：`"已到达边界，无法继续前进！"`

#### 4.3.2. 功能反馈

* **撤销成功**：`"已撤销到位置 (x, y)"`
* **撤销失败**：`"已在起点，无法撤销！"`
* **保存成功**：`"游戏已保存到 saves/game.save"`
* **加载成功**：`"存档加载成功！"`
* **文件不存在**：`"存档文件不存在！"`

#### 4.3.3. 胜利界面

当玩家到达终点时，显示胜利信息：

```text
===================================
        🎉 恭喜通关！🎉
===================================
总步数: 45
移动路径: (1,1) → (1,2) → (2,2) → ...
用时: 3分25秒（可选）
===================================
1. 查看路径回放
2. 返回主菜单
3. 退出程序
===================================
请选择 (1-3): _
```

### 4.4. 帮助信息界面

当用户输入 `HELP` 时，显示详细的帮助信息：

```text
===================================
            帮助信息
===================================
【移动指令】
  W - 向上移动一格
  A - 向左移动一格
  S - 向下移动一格
  D - 向右移动一格

【功能指令】
  P - 打印从起点到当前位置的完整路径
  U - 撤销上一步移动（返回上一个位置）
  R - 自动回放整个移动过程
  SAVE - 保存当前游戏进度
  LOAD - 加载之前保存的游戏
  HELP - 显示此帮助信息
  QUIT - 退出当前游戏

【游戏规则】
  * 使用 W/A/S/D 控制角色移动
  * 从起点 'S' 到达终点 'E' 即可通关
  * '#' 表示墙壁，不可通过
  * '·' 表示可通行的道路
===================================
按回车键返回游戏...
```

### 4.5. 实现要点

1. **输入处理**
   * 支持大小写输入（如 `w` 和 `W` 都有效）
   * 对于连续指令（如 `WWWDD`），逐个解析并执行
   * 提供输入验证和错误提示

2. **界面刷新**
   * 使用跨平台的清屏方法（Windows: `system("cls")`，Linux/Mac: `system("clear")`）
   * 或使用 ANSI 转义序列实现更好的显示效果

3. **用户体验**
   * 提供清晰的提示信息
   * 对错误输入给予友好反馈
   * 支持随时查看帮助和退出游戏

## 5. 实施计划 (Roadmap)

1. **阶段一：基础框架搭建**
   * [ ] **任务1**: 定义 `Maze` 和 `Player` 的基本结构。
   * [ ] **任务2**: 实现地图加载和显示功能。
   * [ ] **任务3**: 实现主菜单和地图选择界面。
   * [ ] **任务4**: 实现基本的玩家移动逻辑（无碰撞检测）。

2. **阶段二：核心功能实现**
   * [ ] **任务5**: 实现墙壁和边界的碰撞检测。
   * [ ] **任务6**: 引入 `std::stack` 实现移动历史记录和撤销（Undo）功能。
   * [ ] **任务7**: 实现路径打印（'P'）和终点检测功能。
   * [ ] **任务8**: 完善游戏进行中的交互界面和提示信息。

3. **阶段三：扩展功能开发**
   * [ ] **任务9**: 引入 `std::vector<char>` 记录指令，并实现路径回放（'R'）功能。
   * [ ] **任务10**: 实现游戏状态的保存（'SAVE'）与加载（'LOAD'）。
   * [ ] **任务11**: (可选) 开发迷宫生成器模块。
   * [ ] **任务12**: (可选) 将系统重构为支持多玩家的回合制模式。

4. **阶段四：测试与文档**
   * [ ] **任务13**: 对所有功能进行全面测试，修复 Bug。
   * [ ] **任务14**: 优化用户界面和交互体验。
   * [ ] **任务15**: 撰写最终的项目报告和使用说明。

---

## 6. C++ 代码规范与标准

### 6.1. 编码规范参考

为保证代码的可读性和可维护性，项目将遵循以下 C++ 编码规范：

1. **命名规范**
   * **类名**: 使用大驼峰命名法（PascalCase），例如 `Maze`, `Player`, `GameState`
   * **函数/方法名**: 使用小写字母加下划线（snake_case），例如 `load_map()`, `is_wall()`, `get_start_pos()`
   * **变量名**: 使用小写字母加下划线（snake_case），例如 `map_data`, `current_pos`, `move_history`
   * **常量**: 使用全大写字母加下划线，例如 `MAX_MAP_SIZE`, `DEFAULT_DELAY`
   * **私有成员变量**: 添加下划线后缀，例如 `map_data_`, `player_pos_`

2. **文件组织**
   * 头文件使用 `.h` 或 `.hpp` 扩展名
   * 实现文件使用 `.cpp` 扩展名
   * 每个类应有独立的头文件和实现文件
   * 使用 `#pragma once` 或传统的头文件保护宏

3. **代码风格**
   * 缩进使用 4 个空格（不使用 Tab）
   * 左花括号 `{` 不换行（K&R 风格）
   * 每行代码长度不超过 100 字符
   * 适当使用空行分隔逻辑块
   * 所有公共接口函数必须添加注释说明

4. **C++ 标准**
   * 使用 C++17 或 C++20 标准
   * 优先使用 STL 容器和算法
   * 使用智能指针（`std::unique_ptr`, `std::shared_ptr`）管理动态内存
   * 使用 `const` 和 `constexpr` 提高代码安全性

### 6.2. 模块化设计参考

项目将采用模块化设计，将功能分解为独立的模块，便于开发、测试和维护。

#### 6.2.1. 文件结构参考

```text
4_PJ/PJ1/
├── include/              # 头文件目录
│   ├── Maze.h           # 迷宫类声明
│   ├── Player.h         # 玩家类声明
│   ├── Game.h           # 游戏控制类声明
│   ├── MazeGenerator.h  # 迷宫生成器类（扩展功能）
│   └── GameState.h      # 游戏状态类声明
├── src/                 # 源文件目录
│   ├── Maze.cpp         # 迷宫类实现
│   ├── Player.cpp       # 玩家类实现
│   ├── Game.cpp         # 游戏控制类实现
│   ├── MazeGenerator.cpp # 迷宫生成器实现（可选）
│   ├── GameState.cpp    # 游戏状态类实现
│   └── main.cpp         # 主程序入口
├── data/                # 数据文件目录
│   ├── Maze1.txt
│   └── Maze2.txt
├── saves/               # 存档文件目录
├── Makefile             # 编译配置文件
└── README.md            # 项目说明文档
```

#### 6.2.2. 核心模块设计参考

1. **Maze 模块** - 负责迷宫地图的加载、存储和显示
   * `load()`: 从文件加载迷宫
   * `is_wall()`: 检查坐标是否可通行
   * `get_start_pos()` / `get_end_pos()`: 获取起点和终点
   * `display()`: 显示迷宫和玩家位置

2. **Player 模块** - 管理玩家状态和移动历史
   * `move()`: 移动玩家并记录到历史栈
   * `undo()`: 撤销上一步移动
   * `get_position()`: 获取当前位置
   * 使用 `std::stack` 存储移动历史，`std::vector` 存储指令序列

3. **Game 模块** - 游戏主控制逻辑
   * `run()`: 主游戏循环
   * `process_command()`: 处理用户输入指令（W/A/S/D/P/U/R/SAVE/LOAD）
   * `print_path()`: 打印完整移动路径
   * `replay()`: 回放移动过程
   * `save_game()` / `load_game()`: 状态保存与恢复

4. **GameState 模块** - 游戏状态序列化
   * 封装需要保存的游戏数据
   * 提供文件读写接口

5. **MazeGenerator 模块**（可选扩展）- 迷宫生成
   * 使用随机 DFS 算法生成迷宫
   * 保存生成的迷宫到文件

---

## 7. 编译与构建

### 7.1. 使用 Makefile 编译

项目使用 Makefile 简化编译过程。常用命令：

```bash
make          # 编译项目
make run      # 编译并运行
make clean    # 清理编译产物
make debug    # 编译调试版本
```

### 7.2. Makefile 基本配置示例

```makefile
CXX := g++
CXXFLAGS := -std=c++17 -Wall -Wextra -O2
INCLUDES := -Iinclude

all: maze_game

maze_game: src/*.cpp
	$(CXX) $(CXXFLAGS) $(INCLUDES) src/*.cpp -o maze_game

clean:
	rm -f maze_game

.PHONY: all clean
```

### 7.3. 手动编译

如果不使用 Makefile，可以直接编译：

```bash
g++ -std=c++17 -Wall -Wextra -O2 -Iinclude src/*.cpp -o maze_game
```

---

## 8. 项目开发流程建议

1. **第一步：搭建基础框架**
   * 创建目录结构
   * 编写 Makefile
   * 实现 `Maze` 类的基本功能（加载和显示）
   * 测试编译是否成功

2. **第二步：实现核心功能**
   * 实现 `Player` 类
   * 实现 `Game` 类的基本移动逻辑
   * 实现撤销功能
   * 每实现一个功能后立即测试

3. **第三步：完善基本功能**
   * 实现路径打印
   * 实现终点检测
   * 优化用户界面

4. **第四步：开发扩展功能**
   * 按优先级实现扩展功能
   * 每个扩展功能独立测试

5. **第五步：整体测试与优化**
   * 进行完整的功能测试
   * 修复 Bug
   * 优化代码性能和可读性
   * 完善文档
